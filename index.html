<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Drop n Drop</title>
    <style>
        :root {
            --primary-bg: #ffffff;
            --secondary-bg: #f0f0f0;
            --border-color: #cccccc;
            --text-color: #1a1a1a;
            --accent-color: #007bff;
            --accent-hover: #0056b3;
            --danger-color: #dc3545;
        }
        body {
            margin: 0; padding: 0; background-color: var(--secondary-bg); color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex;
            justify-content: center; align-items: center; height: 100vh; overflow: hidden;
        }
    
        /* --- MULAI MODIFIKASI DI SINI --- */
        @keyframes animateGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
    
        #game-container {
            width: 100%; max-width: 400px; aspect-ratio: 9 / 16; position: relative;
            
            /* Latar belakang gradasi animasi */
            background: linear-gradient(45deg, #e6f7ff, #fdf8e1, #e6f7ff, #fdf8e1);
            background-size: 400% 400%;
            animation: animateGradient 15s ease infinite;
            
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1); display: flex; flex-direction: column;
            overflow: hidden; border: 1px solid var(--border-color);
        }
        /* --- AKHIR MODIFIKASI --- */
    
        #info-bar {
            padding: 10px; text-align: center; font-size: 1.5em; font-weight: bold;
            background-color: transparent; /* Ubah agar transparan */ 
            border-bottom: 2px solid var(--border-color);
            flex-shrink: 0;
        }
        #score-display::before { content: 'Skor: '; }
        #canvas-wrapper { height: 85%; width: 100%; background-color: transparent; } /* Ubah agar transparan */
        canvas { width: 100%; height: 100%; display: block; }
        #controls {
            height: 15%; width: 100%; background-color: rgba(240, 240, 240, 0.7); /* Beri sedikit transparansi */
            display: flex; justify-content: center; align-items: center;
            border-top: 2px solid var(--border-color);
            backdrop-filter: blur(4px); /* Efek blur (opsional, tapi keren) */
        }
        #drop-button {
            padding: 15px 50px; font-size: 1.5em; font-weight: bold; color: white;
            background-color: var(--accent-color); border: none; border-radius: 12px;
            cursor: pointer; transition: background-color 0.3s, transform 0.1s;
        }
        #drop-button:hover { background-color: var(--accent-hover); }
        #drop-button:active { transform: scale(0.95); }
        #drop-button:disabled { background-color: #999; cursor: not-allowed; }
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.8); display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
            color: var(--text-color); z-index: 10;
            backdrop-filter: blur(4px); /* Efek blur (opsional, tapi keren) */
        }
        .overlay h1 { font-size: 2.5em; margin-bottom: 20px; }
        .overlay p { font-size: 1.2em; margin-bottom: 30px; }
        .button {
            padding: 15px 30px; font-size: 1.2em; font-weight: bold; color: #fff;
            background-color: var(--danger-color); border: none; border-radius: 10px;
            cursor: pointer; transition: background-color 0.3s;
        }
        .button:hover { background-color: #c82333; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="info-bar"><span id="score-display">0</span></div>
        <div id="canvas-wrapper"><canvas id="gameCanvas"></canvas></div>
        <div id="controls"><button id="drop-button">JATUHKAN</button></div>
        <div id="start-screen" class="overlay">
            <h1>Drop n Drop</h1>
            <p>Atur posisi barang, lalu jatuhkan untuk menggabungkannya!</p>
            <button id="start-button" class="button" style="background-color: #28a745;">Mulai Game</button>
        </div>
        <div id="game-over-screen" class="overlay hidden">
            <h1>Game Over</h1>
            <p>Skor Akhir: <span id="final-score">0</span></p>
            <button id="restart-button" class="button">Coba Lagi</button>
        </div>
    </div>

    <script>
        // --- Elemen UI ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dropButton = document.getElementById('drop-button');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const scoreDisplay = document.getElementById('score-display');
        const finalScoreDisplay = document.getElementById('final-score');

        // --- Pengaturan Game ---
        const COLS = 4;
        let ROWS, BLOCK_SIZE;
        const ITEMS = { EMPTY: 0, BOX: 1, KOPER: 2, PESAWAT: 3 };

        function setCanvasDimensions() {
            const wrapper = document.getElementById('canvas-wrapper');
            canvas.width = wrapper.offsetWidth;
            canvas.height = wrapper.offsetHeight;
            BLOCK_SIZE = canvas.width / COLS;
            ROWS = Math.floor(canvas.height / BLOCK_SIZE);
        }

        const ITEM_PROPS = {
            [ITEMS.BOX]:     { src: 'https://yanoshijapan.github.io/asetonline/dus.png', img: null },
            [ITEMS.KOPER]:   { src: 'https://yanoshijapan.github.io/asetonline/ckoper.png', img: null },
            [ITEMS.PESAWAT]: { src: 'https://yanoshijapan.github.io/asetonline/pesawat.png', img: null }
        };

        function loadImages(callback) {
            const totalImages = Object.keys(ITEM_PROPS).length;
            let loadedCount = 0;
            const onImageLoadOrError = () => {
                loadedCount++;
                if (loadedCount === totalImages) {
                    callback();
                }
            };
            for(const key in ITEM_PROPS) {
                const item = ITEM_PROPS[key];
                item.img = new Image();
                item.img.crossOrigin = "Anonymous";
                item.img.src = item.src;
                item.img.onload = onImageLoadOrError;
                item.img.onerror = () => {
                    console.error(`Gagal memuat gambar: ${item.src}.`);
                    onImageLoadOrError();
                };
            }
        }
        
        // --- Variabel Status Game ---
        let grid, currentItem, score, isGameOver, isDropping;
        let animationFrameId;
        
        // --- BARU: Array untuk menyimpan skor yang beranimasi ---
        let floatingScores = [];

        // --- Class & Fungsi Inti ---
        class Item {
            constructor(type, x, y) { this.type = type; this.x = x; this.y = y; }
        }
        
        function init() {
            setCanvasDimensions();
            grid = Array.from({ length: ROWS }, () => Array(COLS).fill(ITEMS.EMPTY));
            score = 0; isGameOver = false; isDropping = false;
            floatingScores = []; // Kosongkan array saat game baru
            scoreDisplay.textContent = score;
            dropButton.disabled = false;
            spawnNewItem();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }

        function spawnNewItem() {
            const randomType = Math.floor(Math.random() * 3) + 1;
            currentItem = new Item(randomType, Math.floor(COLS / 2), 0);
            if (checkCollision(currentItem.x, currentItem.y)) isGameOver = true;
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#dc3545'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(0, BLOCK_SIZE); ctx.lineTo(canvas.width, BLOCK_SIZE); ctx.stroke();
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c] !== ITEMS.EMPTY) drawBlock(c, r, grid[r][c]);
                }
            }
            if (currentItem && !isGameOver) drawBlock(currentItem.x, currentItem.y, currentItem.type);

            // --- BARU: Panggil fungsi untuk menggambar skor animasi ---
            handleFloatingScores();
        }

        // --- BARU: Fungsi untuk menangani logika dan penggambaran skor animasi ---
        function handleFloatingScores() {
            // Kita akan memproses array dari belakang agar aman saat menghapus elemen
            for (let i = floatingScores.length - 1; i >= 0; i--) {
                const fs = floatingScores[i];

                // Update posisi & transparansi
                fs.y -= 0.5; // Bergerak ke atas
                fs.lifetime--;
                fs.alpha = fs.lifetime / 60; // 60 adalah durasi awal

                // Gambar teks skor
                ctx.font = `bold ${BLOCK_SIZE * 0.5}px Arial`;
                ctx.fillStyle = `rgba(76, 175, 80, ${fs.alpha})`; // Warna hijau
                ctx.textAlign = 'center';
                ctx.fillText(fs.text, fs.x, fs.y);

                // Hapus dari array jika sudah tidak terlihat
                if (fs.lifetime <= 0) {
                    floatingScores.splice(i, 1);
                }
            }
        }


        function drawBlock(x, y, type) {
            const props = ITEM_PROPS[type];
            if (props && props.img && props.img.complete && props.img.naturalHeight !== 0) {
                ctx.drawImage(props.img, x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            } else {
                ctx.fillStyle = '#ccc';
                ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            }
        }
        
        function dropItem() {
            if (isDropping || isGameOver || !currentItem) return;
            isDropping = true;
            dropButton.disabled = true;

            let dropAnimationFrame;
            let currentPixelY = currentItem.y * BLOCK_SIZE;
            const dropSpeed = BLOCK_SIZE / 2; 

            function animateDrop() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                currentPixelY += dropSpeed;
                const nextGridY = Math.floor((currentPixelY + BLOCK_SIZE -1) / BLOCK_SIZE);
                if (checkCollision(currentItem.x, nextGridY)) {
                    currentItem.y = nextGridY - 1;
                    solidifyItem();
                    checkMerges();
                    spawnNewItem();
                    isDropping = false;
                    dropButton.disabled = isGameOver;
                    cancelAnimationFrame(dropAnimationFrame);
                    gameLoop(); 
                    return;
                }
                currentItem.y = currentPixelY / BLOCK_SIZE;
                draw();
                dropAnimationFrame = requestAnimationFrame(animateDrop);
            }
            animateDrop();
        }

        function gameLoop() {
            if(isDropping) return;
            if (!isGameOver) {
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                showGameOver();
            }
        }

        function showGameOver() {
            finalScoreDisplay.textContent = score;
            gameOverScreen.classList.remove('hidden');
            dropButton.disabled = true;
        }

        function checkCollision(x, y) {
            if (x < 0 || x >= COLS || y >= ROWS) return true;
            return grid[y] && grid[y][x] !== ITEMS.EMPTY;
        }

        function solidifyItem() {
            // Pastikan y adalah integer sebelum dimasukkan ke grid
            currentItem.y = Math.round(currentItem.y);
            if (currentItem.y < ROWS) grid[currentItem.y][currentItem.x] = currentItem.type;
            if (currentItem.y < 1) isGameOver = true;
        }

        function checkMerges() {
            for (let r = ROWS - 1; r > 0; r--) {
                for (let c = 0; c < COLS; c++) {
                    const currentType = grid[r][c];
                    const aboveType = grid[r - 1][c];
                    let merged = false;
                    let points = 0;

                    if (currentType !== ITEMS.EMPTY && currentType === aboveType) {
                        if (currentType === ITEMS.BOX) {
                            grid[r][c] = ITEMS.KOPER; points = 5; merged = true;
                        } else if (currentType === ITEMS.KOPER) {
                            grid[r][c] = ITEMS.PESAWAT; points = 10; merged = true;
                        } else if (currentType === ITEMS.PESAWAT) {
                            points = 25;
                            for (let row = r; row > 1; row--) { grid[row][c] = grid[row - 2] ? grid[row - 2][c] : ITEMS.EMPTY; }
                            grid[0][c] = ITEMS.EMPTY; grid[1][c] = ITEMS.EMPTY; merged = true;
                        }

                        if (merged) {
                            score += points;
                            // --- DIMODIFIKASI: Tambahkan objek skor baru ke array animasi ---
                            floatingScores.push({
                                text: `+${points}`,
                                x: (c + 0.5) * BLOCK_SIZE, // Posisi X di tengah balok
                                y: r * BLOCK_SIZE,         // Posisi Y di atas balok
                                lifetime: 60,              // Durasi animasi (60 frame ~ 1 detik)
                                alpha: 1.0                 // Mulai dengan terlihat jelas
                            });

                            if (currentType !== ITEMS.PESAWAT) {
                                for (let row = r - 1; row > 0; row--) { grid[row][c] = grid[row - 1][c]; }
                                grid[0][c] = ITEMS.EMPTY;
                            }
                            scoreDisplay.textContent = score; 
                            return checkMerges();
                        }
                    }
                }
            }
        }
        
        // --- Kontrol & Event Listeners ---
        function handleMove(event) {
            if (!currentItem || isGameOver || isDropping) return;
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const x = clientX - rect.left;
            let newCol = Math.floor(x / BLOCK_SIZE);
            newCol = Math.max(0, Math.min(COLS - 1, newCol));
            if (!checkCollision(newCol, currentItem.y)) currentItem.x = newCol;
        }
        canvas.addEventListener('mousedown', (e) => handleMove(e));
        canvas.addEventListener('mousemove', (e) => { if(e.buttons === 1) handleMove(e); });
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleMove(e); }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); }, { passive: false });

        dropButton.addEventListener('click', dropItem);
        startButton.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            init();
        });
        restartButton.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            init();
        });
        
        window.addEventListener('resize', init);
        window.addEventListener('load', () => {
            startButton.textContent = "Memuat Aset..."; startButton.disabled = true;
            loadImages(() => {
                startButton.textContent = "Mulai Game"; startButton.disabled = false;
                setCanvasDimensions();
            });
        });
    </script>
</body>
</html>
